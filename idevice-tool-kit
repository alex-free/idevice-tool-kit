# Global vars.
os="$(uname)"
arch="$(uname -m)"
device=
# If false A10.
a9=false
ver=
serial=
not_normal=false
ipsw_file=
# Used to check if we need iOS 15 to be restored to get activation files, it doubles as a disable to prevent a recursive infinite loop when calling the restore_ipsw() func as well.
restore_signed_ios=false
# Need to do more steps for final restore.
not_final_restore=true

usbmuxd_restart() {
    # Restart in normal non-pulling mode daemonized.
    killall usbmuxd > /dev/null 2>&1
    usbmuxd > /dev/null 2>&1
}

update_existing_data() {
    if [ -d "$1"/data ]; then
        echo "Found existing data folder!"
        cp -rv "$1"/data .
        echo "Copied existing data folder!"
    else
        echo "Error: Could not find the data folder in $1!"
        exit 1
    fi

    # Don't print error messages if no boot-* files exist.
    cp -rv "$2"/boot-* . 2>/dev/null 
}

set_path() {
    # OS/arch detection.
    # Add all the self-contained binaries we need to the $PATH used within this script.
    if [ "$os" = "Linux" ]; then

        if [ "$arch" = "x86_64" ]; then
            PATH="${PATH:+$PATH:}$real_portable_folder/bin:$real_portable_folder/bin/Legacy-iOS-Kit/bin/linux/x86_64:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_linux-amd64/bin"
        elif [ "$arch" = "arm64" ]; then
            PATH="${PATH:+$PATH:}$real_portable_folder/bin:$real_portable_folder/bin/Legacy-iOS-Kit/bin/linux/arm64:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_linux-arm64/bin"
        else
            echo "Error: Linux on $arch is not supported."
            exit 1
        fi

        echo "Detected Linux on $arch."

    elif [[ "$os" == "Darwin" ]]; then
        PATH="${PATH:+$PATH:}$real_portable_folder/bin:$real_portable_folder/bin/Legacy-iOS-Kit/bin/macos:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_macos/bin"
        echo "Detected Mac OS on $arch."
    else
        echo "Error: $os is not supported."
        exit 1
    fi

    echo "PATH: $PATH"    
}

startup() {

    if [ ! -d data ]; then
        echo "Creating data folder..."
        mkdir data
    else
        echo "Loaded existing data folder!"
    fi

    # Create ipsw directory if it does not exist.
    mkdir -p data/ipsw

    if [ "$os" = "Linux" ]; then
        # On Linux we need root.
        if [ "$EUID" -ne 0 ]; then
            echo "Error: a999 must be ran with root privileges on Linux. Please execute it with sudo or as the root user to continue."
            exit 1
        fi
    fi

    if [ ! -f "bin/Legacy-iOS-Kit/resources/firstrun" ]; then
        (cd bin/Legacy-iOS-Kit && ./restore.sh --no-version-check --no-internet-check)
        # This is to account for LibUSB being just installed.

        if [ "$os" = "Linux" ]; then
            if command -v dnf >/dev/null; then
                # More deps.
                dnf install -y libimobiledevice libimobiledevice-utils expect idevicerestore irecovery
            elif command -v apt >/dev/null; then
                apt install --yes expect libimobiledevice libimobiledevice-utils expect idevicerestore irecovery
            fi
        fi

        read -p "Please disconnect then reconnect your USB-A Lightning cable to ensure the iPhone can be detected.Then press any key to continue..."
    fi

    # Additional setup.
    if [ "$os" = "Linux" ]; then
        # https://github.com/alex-free/a999activator/issues/8#issuecomment-3383734504
        if command -v dnf >/dev/null; then
            # Crypto libraries for lockdown.
            update-crypto-policies --set LEGACY > /dev/null 2>&1
            # Crypto policies usually require a reboot to take effect.
            # Set SE linux to permissive (resets on Reboot)
            setenforce 0
            # Deps.
        fi
    elif [ "$os" = "Darwin" ]; then
        # All these executables are signed so that is the only think preventing gatekeeper from allowing the script to be automatic is the quarintine attributes.
        # Remove any quarintine attributes in this folder.
        xattr -rc .
    else
        echo "Error: unsupported operating system!"
        exit 1
    fi
}

generate_boot_script(){
    boot_script=boot_"$device"_"$ver"_"$serial"

    # Delete any existing boot* scripts for this serial number.
    rm -f *-$serial
    
    if [ "$a9" = "true" ]; then
        echo -e '#!/bin/bash

real_portable_folder="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$real_portable_folder"
os="$(uname)"
arch="$(uname -m)"

# OS/arch detection.
# Add all the self-contained binaries we need to the $PATH used within this script.
if [ "$os" = "Linux" ]; then

    if [ "$arch" = "x86_64" ]; then
        PATH="${PATH:+$PATH:}$real_portable_folder/bin:$real_portable_folder/bin/Legacy-iOS-Kit/bin/linux/x86_64:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_linux-amd64/bin"
    elif [ "$arch" = "arm64" ]; then
        PATH="${PATH:+$PATH:}$real_portable_folder/bin:$real_portable_folder/bin/Legacy-iOS-Kit/bin/linux/arm64:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_linux-arm64/bin"
    else
        echo "Error: Linux on $arch is not supported."
        exit 1
    fi

    echo "Detected Linux on $arch."

elif [ "$os" == "Darwin" ]; then
    PATH="${PATH:+$PATH:}$real_portable_folder/bin:$real_portable_folder/bin/Legacy-iOS-Kit/bin/macos:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_macos/bin"
    echo "Detected Mac OS on $arch."
else
    echo "Error: $os is not supported."
    exit 1
fi

echo "PATH: $PATH"   

if [ "$os" = "Linux" ]; then

    if [ "$EUID" -ne 0 ]; then
        echo "Error: root privileges are required to boot your iPhone. Please execute $0 with sudo or as root to continue." >&2
        exit 1
    fi

    usbmuxd_restart_polling > /dev/null 2>&1
fi

# Can not trust return values of turdusra1n because at least my 128GB TSMC 6S Plus reboots to recovery very occasionally. This has never happened on my 32GB TSMC 6S Plus.
while irecovery -m 2>/dev/null | grep -q "Recovery Mode"; do
    echo "If you get an error about failed to open handle (no device) after Checkmate?, disconnect then reconnect your iPhone."

    while ! turdusra1n -TP data/'$device'_'$serial'/'$ver'/block/*-pteblock2.bin; do 
        echo "Something went wrong, lets try that again..."
    done

    echo "Please wait, checking for proper booting in 20 seconds"
    sleep 20
done

# Restart in normal non-pulling mode daemonized.
killall usbmuxd > /dev/null 2>&1
usbmuxd
echo "Done!"

' > $boot_script

    #A10.
    else
        echo -e '#!/bin/bash

real_portable_folder="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$real_portable_folder"
os="$(uname)"
arch="$(uname -m)"

# OS/arch detection.
# Add all the self-contained binaries we need to the $PATH used within this script.
if [ "$os" = "Linux" ]; then

    if [ "$arch" = "x86_64" ]; then
        PATH="${PATH:+$PATH:}$real_portable_folder/bin:$real_portable_folder/bin/Legacy-iOS-Kit/bin/linux/x86_64:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_linux-amd64/bin"
    elif [ "$arch" = "arm64" ]; then
        PATH="${PATH:+$PATH:}$real_portable_folder/bin:$real_portable_folder/bin/Legacy-iOS-Kit/bin/linux/arm64:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_linux-arm64/bin"
    else
        echo "Error: Linux on $arch is not supported."
        exit 1
    fi

    echo "Detected Linux on $arch."

elif [ "$os" == "Darwin" ]; then
    PATH="${PATH:+$PATH:}$real_portable_folder/bin:$real_portable_folder/bin/Legacy-iOS-Kit/bin/macos:$real_portable_folder/bin/turdus_m3rula_1.1_b0ea3ee7_macos/bin"
    echo "Detected Mac OS on $arch."
else
    echo "Error: $os is not supported."
    exit 1
fi

echo "PATH: $PATH"   

if [ "$os" = "Linux" ]; then

    if [ "$EUID" -ne 0 ]; then
        echo "Error: root privileges are required to boot your iPhone. Please execute $0 with sudo or as root to continue." >&2
        exit 1
    fi

    usbmuxd_restart_polling > /dev/null 2>&1
fi

# Can not trust return values of turdusra1n because at least my 128GB TSMC 6S Plus reboots to recovery very occasionally. This has never happened on my 32GB TSMC 6S Plus.
while irecovery -m 2>/dev/null | grep -q "Recovery Mode"; do

    while ! turdusra1n -t data/'$device'_'$serial'/'$ver'/image4/*'$boot_script_ver'-iBoot.img4 -i data/'$device'_'$serial'/'$ver'/image4/*signed-SEP.img4 -p data/'$device'_'$serial'/'$ver'/image4/*'$boot_script_ver'-SEP.im4p; do
        echo "Something went wrong, lets try that again..."
    done

    echo "Please wait, checking for proper booting in 20 seconds"
    sleep 20
done

# Restart in normal non-pulling mode daemonized.
killall usbmuxd > /dev/null 2>&1
usbmuxd
echo "Done!"

' > $boot_script

    fi

    chmod 755 $boot_script
    # Clips the last character otherwise in the echo below.
    boot_script=$(echo "$boot_script" | tr -d '\r')
    echo "If your phone is powered off or rebooted, it will first boot to Recovery Mode. You'll need to run the new $boot_script command to boot it into normal mode."
}

pair_iphone(){
    idevicepair pair >/dev/null 2>&1
}

detect_iphone() {
    # Start usbmuxd in foreground using polling option.
    if [ "$os" = "Linux" ]; then
        usbmuxd_restart_polling > /dev/null 2>&1
    fi

    echo "Searching for an iPhone connected to this computer with a USB-A Lightning cable. Please wait..."

    # Need the serial number to identify what cached data to use. This is available in Recovery Mode and Normal mode, but not in DFU Mode so we don't allow this to run until we get into Recovery Mode if DFU Mode is detected.
    echo "Checking for iPhone in DFU Mode..."

    if irecovery -m 2>/dev/null | grep -q "DFU Mode"; then
        wait_for_recovery
    fi

    # Loop until the iPhone can be detected in Recovery Mode or Normal Mode. It sure as hell aint in DFU Mode at this point...
    while true; do

        echo "Checking for iPhone in Recovery Mode..."

        if irecovery -m 2>/dev/null | grep -q "Recovery Mode"; then
            echo "Info: iPhone was found in Recovery Mode."
            not_normal=true
            serial=$(irecovery -q 2>/dev/null | grep -i 'SRNM:' | awk '{print $2}')

            if irecovery -q 2>/dev/null |  grep '^PRODUCT: iPhone8,1'; then
                echo "iPhone 6S detected!"
                device=iphone_6s

            elif irecovery -q 2>/dev/null | grep -q '^PRODUCT: iPhone8,2'; then
                echo "iPhone 6S Plus detected!"
                device=iphone_6s_plus
            
            elif irecovery -q 2>/dev/null | grep -q '^PRODUCT: iPhone8,4'; then
                echo "iPhone SE detected!"
                device=iphone_se
            
            elif irecovery -q 2>/dev/null | grep '^PRODUCT: iPhone9,1'; then
                echo "iPhone 7 detected!"
                device=iphone_7
                break
            elif irecovery -q 2>/dev/null | grep '^PRODUCT: iPhone9,3'; then
                echo "iPhone 7 detected!"
                device=iphone_7
                break
            
            elif irecovery -q 2>/dev/null | grep -q '^PRODUCT: iPhone9,2'; then
                echo "iPhone 7 Plus detected!"
                device=iphone_7_plus
                break
            elif irecovery -q 2>/dev/null | grep -q '^PRODUCT: iPhone9,4'; then
                echo "iPhone 7 Plus detected!"
                device=iphone_7_plus
                break
            else
                echo "Error: could not find a supported iPhone. If you have a supported iPhone, make sure it is connected with a Lightning to USB-A cable to this computer and try again."
                exit 1
            fi

            if irecovery -q 2>/dev/null | grep -q '^CPID: 0x8003'; then
                echo "Info: TSMC A9 chip detected!"
                break
            elif irecovery -q 2>/dev/null | grep -q '^CPID: 0x8001'; then
                echo "Info: Samsung A9X chip detected! You must have an iPad Pro!"
                break
            elif irecovery -q 2>/dev/null | grep -q '^CPID: 0x8000'; then
                echo "Info: Samsung A9 chip detected!"
                break
            fi

        else
            # Gets here if no iPhone is connected as well so set special arg.
            echo "Checking for iPhone in Normal Mode..."
            pair_iphone
            serial=$(ideviceinfo 2>/dev/null | grep -i '^SerialNumber:' | awk '{print $2}')
            
            if ideviceinfo 2>/dev/null | grep -q '^ProductType: iPhone8,1' > /dev/null 2>&1; then
                echo "iPhone 6S detected!"
                device=iphone_6s
            
            elif ideviceinfo 2>/dev/null | grep -q '^ProductType: iPhone8,2' > /dev/null 2>&1; then
                echo "iPhone 6S Plus detected!"
                device=iphone_6s_plus
            
            elif ideviceinfo 2>/dev/null | grep -q '^ProductType: iPhone8,4' > /dev/null 2>&1; then
                echo "iPhone SE detected!"
                device=iphone_se

            elif ideviceinfo 2>/dev/null | grep -q '^ProductType: iPhone9,1' > /dev/null 2>&1; then
                echo "iPhone 7 detected!"
                device=iphone_7
                break
            elif ideviceinfo 2>/dev/null | grep -q '^ProductType: iPhone9,3' > /dev/null 2>&1; then
                echo "iPhone 7 detected!"
                device=iphone_7
                break

            elif ideviceinfo 2>/dev/null | grep -q '^ProductType: iPhone9,2' > /dev/null 2>&1; then
                echo "iPhone 7 Plus detected!"
                device=iphone_7_plus
                break
            elif ideviceinfo 2>/dev/null | grep -q '^ProductType: iPhone9,4' > /dev/null 2>&1; then
                echo "iPhone 7 Plus detected!"
                device=iphone_7_plus
                break

            else
                echo "Error: could not find a supported iPhone. If you have a supported iPhone, make sure it is connected with a Lightning to USB-A cable to this computer and try again. If it is in Normal mode, it needs to be trusted to this computer to be detected."
                exit 1
            fi

            if ideviceinfo 2>/dev/null |  grep -q '^HardwarePlatform: s8003'; then
                echo "Info: TSMC A9 chip detected!"
                break
            elif ideviceinfo 2>/dev/null |  grep -q '^HardwarePlatform: s8001'; then
                echo "Info: Samsung A9X chip detected! You must have an iPad Pro!"
                break
            elif ideviceinfo 2>/dev/null |  grep -q '^HardwarePlatform: s8000'; then
                echo "Info: Samsung A9 chip detected!"
                break
            fi
        fi
    done

    if [ "$device" = "iphone_6s" ] || [ "$device" = "iphone_6s_plus" ] || [ "$device" = "iphone_se" ]; then
        a9=true
    fi

    echo "Serial Number Identifier: $serial"
}

# Note: this only does so much because it appears that if the iPhone was in DFU Mode and then exited it will auto-boot=true.
enforce_recovery() {
    irecovery -c "setenv auto-boot false"
    irecovery -c "saveenv"
}

boot_turdusra1n() {
    wait_for_recovery

    # Can not trust return values of turdusra1n because at least my 128GB TSMC 6S Plus reboots to recovery very occasionally. This has never happened on my 32GB TSMC 6S Plus. It appears to be an issue with turdus merula because it won't show as much output (never gets to bootx) but still returns 0.
    while irecovery -m 2>/dev/null | grep -q "Recovery Mode"; do
        echo "Info: If you get an error about failed to open handle (no device) after Checkmate?, disconnect then reconnect your iPhone."
        
        if [ "$a9" = "true" ]; then
        
            while ! turdusra1n -TP data/"$device"_"$serial"/$ver/block/*-pteblock2.bin; do
                echo "Something went wrong, lets try that again."
            done
        else
            while ! turdusra1n -t data/"$device"_"$serial"/$ver/image4/*iBoot.img4 -i data/"$device"_"$serial"/$ver/image4/*signed-SEP.img4 -p data/"$device"_"$serial"/$ver/image4/*-SEP.im4p; do
                echo "Something went wrong, lets try that again."
            done
        fi
        # Give time to exit Recovery Mode so this is not executed again erronously.
        echo "Please wait, checking for proper booting in 20 seconds"
        sleep 20
    done
}

enter_recovery() {    
    if ! irecovery -m 2>/dev/null | grep -q "Recovery Mode"; then
        # If not in Recovery Mode assume in Normal Mode and attempt to enter Recovery Mode. If this fails we are already in Recovery Mode or possibly DFU Mode so we don't want to show an error."
        if ideviceenterrecovery "$(ideviceinfo -k UniqueDeviceID 2>/dev/null)" >/dev/null 2>&1; then
            # If this succeded lets tell the user what's going on. If it didn't succed then that's ok we don't need to tell them anything due to the above reasoning....
            echo "Entering Recovery Mode, please wait..."
        fi
        
        # If this was DFU Mode this is fine to show the user because it gets them back on track...
        wait_for_recovery
    fi
}

wait_for_normal_mode() {
    echo "Waiting for iPhone to boot into Normal Mode..."

    while ! ideviceinfo 2>/dev/null; do
       # Ensure we are paired.
        pair_iphone
        sleep 1
    done
}

wait_for_recovery() {
    echo "Expecting iPhone to be in Recovery Mode shortly, hang in there!"

     while ! irecovery -m 2>/dev/null | grep -q "Recovery Mode"; do

        if irecovery -m 2>/dev/null | grep -q "DFU Mode"; then
            if [ "$a9" = "true" ]; then
                echo "DFU Mode detected. Please press the HOME+POWER buttons until your iPhone reboots into Recovery Mode. Do not stop pressing those buttons until you get to Recovery Mode."
            else
                echo "DFU Mode detected. Please press the volume down+POWER buttons until your iPhone reboots into Recovery Mode. Do not stop pressing those buttons until you get to Recovery Mode."
            fi

            while irecovery -m 2>/dev/null | grep -q "DFU Mode"; do
                sleep 1
            done

        fi

        sleep 1
    done
    
    echo "Found iPhone in Recovery Mode!"
}

turdursra1n_pwn() {
    wait_for_recovery

    while ! turdusra1n -D; do
        echo "Something went wrong. Lets try that again..."
        sleep 1
    done
}

retry_pwn() {
    echo "Something went wrong, lets try that again."
    turdursra1n_pwn
}

get_ver() {
    # If given URL, using a999activator setup with hardcoded URLs.
    if [[ "$1" == http://* || "$1" == https://* ]]; then
        mkdir -p data/ipsw
        # Check that we have ipsw file.
        ipsw_file="data/ipsw/$(basename "$1")"

        if [ ! -f $ipsw_file ]; then
            echo "Downloading $ipsw_file..."
            
            while ! curl -L $1 -o $ipsw_file; do
                echo "Download failed, trying again."
                rm -f $ipsw_file
            done
        fi
    elif [ -f "$1" ]; then
        ipsw_file="$1"
    fi

    # Get ver and build number, i.e. 9.2_13D20 for possible iPhone 6S downgrade (even though we can't use 13D20 or any 'new' iOS 9.2.1 for other devices because jbme does not work)... Build number is important for iPhone 6S and iPhone 6S Plus which have 2 different iOS 9.2.1 versions available for restore.
    ver=$(echo "$ipsw_file" | sed -E 's/.*_(.*_.*)_Restore\.ipsw/\1/')
        
    # Only iOS version number, needed for A10 boot script.
    if [ "$a9" = "false" ]; then
        boot_script_ver=$(echo "$ipsw_file" | sed -E 's/.*_(.*)_(.*)_Restore\.ipsw/\1/')
    fi
}

restore_ipsw() {
    enter_recovery
    enforce_recovery

    get_ver "$1"

    echo "Restoring iOS $ver with $ipsw_file.."

    mkdir -p data/"$device"_"$serial"/$ver 

    if [ "$a9" = "true" ]; then
        #SHCblock.
        # BUG (in turdus_merula since v1.1). This can exit ok but it really didn't get the PTE block so we need to check again even after it returns 0. This is done for SHCBlock just in case the same could happen (trust issues since PTEBlock surfaced).
        while ! find data/"$device"_"$serial"/$ver/block -type f -name "*restore-shcblock2.bin" 2>/dev/null | grep -q . 2>/dev/null; do
            echo "Getting restore SHCBlock..."
            turdursra1n_pwn

            while ! echo 1 | turdus_merula -C data/"$device"_"$serial"/$ver --get-shcblock $ipsw_file; do
                retry_pwn
            done

            wait_for_recovery
            enforce_recovery
        done

        echo "Restoring..."
        # Restore.
        turdursra1n_pwn

        while ! echo 1 | turdus_merula -C data/"$device"_"$serial"/$ver -o --load-shcblock data/"$device"_"$serial"/$ver/block/*-restore-shcblock2.bin $ipsw_file; do
            retry_pwn
        done

        # Skip the rest if signed ios ver or if intermediete restore (i.e. 10.3.3 before 10.0-10.3.2, or 10.2.1 before 9.x).
        if [ "$not_final_restore" = "true" ]; then
            return
        fi

        while ! find data/"$device"_"$serial"/$ver/block -type f -name "*-current-shcblock2.bin" 2>/dev/null | grep -q . 2>/dev/null; do
            echo "Getting post-restore SHCBlock..."
            cd data/"$device"_"$serial"/$ver
            mkdir -p block

            while ! turdusra1n -g $ipsw_file; do
                echo "Something went wrong, let's try that again..."
            done

            cd ../../../

            wait_for_recovery
            enforce_recovery
        done

        # Get PTEBlock.
        while ! find data/"$device"_"$serial"/$ver/block -type f -name "*-pteblock2.bin" 2>/dev/null | grep -q . 2>/dev/null; do
            echo "Getting PTEBlock..."
            cd data/"$device"_"$serial"/$ver
            mkdir -p block
            
            while ! turdusra1n -g -i image4/*signed-SEP.img4 -C block/*-current-shcblock2.bin $ipsw_file; do
                echo "Something went wrong, let's try that again..."
            done

            cd ../../../
            wait_for_recovery
            enforce_recovery
        done
    else
        echo "Restoring..."
        # Restore.
        turdursra1n_pwn

        while ! echo 1 | turdus_merula -C data/"$device"_"$serial"/$ver -o $ipsw_file; do
            retry_pwn
        done
    fi
}

check_if_additional_restore_is_needed() {

    get_ver "$1"

    if [ "$ver" = "10.0.1_14A403" ] || \
    [ "$ver" = "10.0.2_14A456" ] || \
    [ "$ver" = "10.0.3_14A551" ] || \
    [ "$ver" = "10.1_14B72c" ] || \
    [ "$ver" = "10.1.1_14B100" ] || \
    [ "$ver" = "10.1.1_14B150" ] || \
    [ "$ver" = "10.2_14C92" ] || \
    [ "$ver" = "10.2.1_14D27" ] || \
    [ "$ver" = "10.3_14E277" ] || \
    [ "$ver" = "10.3.1_14E304" ] || \
    [ "$ver" = "10.3.2_14F89" ]; then
        echo "Info: need to restore iOS 10.3.3 first."
    else
        return
    fi

    # Needed for iOS 10.0.1-iOS 10.3.2
    if [ $device == "iphone_6s" ]; then
        restore_ipsw http://appldnld.apple.com/ios10.3.3/091-23441-20170719-CA9B0570-6977-11E7-95CC-3F9100BA0AE3/iPhone_4.7_10.3.3_14G60_Restore.ipsw
    elif [ $device == "iphone_6s_plus" ]; then
        restore_ipsw http://appldnld.apple.com/ios10.3.3/091-23338-20170719-CA990FD6-6977-11E7-AE41-3B9100BA0AE3/iPhone_5.5_10.3.3_14G60_Restore.ipsw
    elif [ $device == "iphone_se" ]; then
        restore_ipsw http://appldnld.apple.com/ios10.3.3/091-23133-20170719-CA8E78E6-6977-11E7-968B-2B9100BA0AE3/iPhone_4.0_64bit_10.3.3_14G60_Restore.ipsw
    elif [ $device == "iphone_7" ]; then
        restore_ipsw http://appldnld.apple.com/ios10.3.3/091-23304-20170719-CA9AC9AC-6977-11E7-9507-349100BA0AE3/iPhone_7_10.3.3_14G60_Restore.ipsw
    elif [ $device == "iphone_7_plus" ]; then
        restore_ipsw http://appldnld.apple.com/ios10.3.3/091-23119-20170719-CA92905C-6977-11E7-AB61-299100BA0AE3/iPhone_7Plus_10.3.3_14G60_Restore.ipsw
    fi
}